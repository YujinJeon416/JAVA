# [7장] 상속
- final 클래스, final 메소드
    - 상속 불가, 오버라이딩 불가
- super()
    - 자바에서 자식 타입을 생성하면, 부모 타입의 객체가 생성된다.
        - Q) **만약 여러 객체를 생성되면, 그 수만큼 `Object`객체가 heap에 할당되나요?**
    - 부모 생성자 호출
    - 자식 생성자 보다 먼저 호출 되어야 한다.
    - 기본 생성자를 생략할 경우


## Promotion(자동 타입 변환)
> 부모 클래스 변수 = 자식 클래스타입;
- 자식 클래스는 부모 타입으로 자동타입 변환 된다.
- `Cat cat = new Cat();`
- `Animal animal = cat;`
- 이때 **`animal과 cat reference는 같다.`**
- **아래는 이에 대한 궁금점..**
    - `./animal.java`
    ```java
    public class Animal {
        String name;

        public Animal(String name){
            this.name = name;
        }

        public String getName(){
            return name;
        }
    }
    ```
    - `./cat.java`
    ```java
    public class Cat extends Animal {
        int type;

        public Cat(String name, int type) {
            super(name);
            this.type = type;
        }

        @Override
        public String getName() {
            return super.getName();
        }

        public int getType(){
            return type;
        }

        public static void main(String[] args) {
            String name = "minwook";
            Cat cat = new Cat(name,1);
            Animal animal = cat;

            String curAnimalName = animal.getName();
            String curCatName = cat.getName();

            int curAnimalType = animal.getType(); // animal 타입으로 promotion된 cat은 cat method를 사용할 수 없다.
            int curCatType = cat.getType();
            System.out.println(animal == cat);  // 그런데 어쨰서 animal == cat (true)가 될까?
        }
    }
    ```
    - **animal type으로 `promotion` 된 녀석은 cat에 비하여 method 제한이 존재하는데, 어째서 animal과 cat이 같은 ref라고 할 수 있는가**
    - 실제로 같은 ref이고 JVM에서 이에 대하여 controll하고 있는 것 같다. 이 원리가 궁금하네

## Casting( 강제 타입 변환 ) 
> 자식 클래스 변수 = (자식 클래스) 부모클래스타입;

- **Q) 캐스팅과 프로모션 사용하면, ref만 바뀌는 것인가 아니면 객체 복사&생성이 이뤄지는 걸까?**
    - [캐스팅과 heap과의 관계](./upCasting_downCasting_Heap)

- 강제 타입 변환은 자식이 부모 타입으로 변형되어 있을 때에만 사용 가능
- 부모 타입 변수가 부모 객체를 가리키고 있을 때는, casting 불가능하다. (내 생각에는 자식 객체를 생성할때는 부모와 자식 둘다 생성하지만, 부모를 호출 할때는 부모만 생성하기 때문이라고 생각한다.)

